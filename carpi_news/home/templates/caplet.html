{% extends 'base.html' %}
{% load static %}

{% block title %}Caplet - Il gioco strategico{% endblock %}

{% block extra_css %}
<meta name="description" content="Gioca a Caplet, il gioco delle bolle nel brodo. Piazza i segnalini seguendo le regole delle zone, righe e colonne.">
{% endblock %}

{% block content %}
<div class="container">
    <!-- Titolo del gioco -->
    <div class="game-header">
        <h1 class="game-title">üç≤ Caplet</h1>
        <p class="game-subtitle">Il gioco delle bolle nel brodo</p>
    </div>

    <!-- Area di gioco -->
    <section class="game-section">
        <div class="game-container">
            <!-- Piatto rotondo -->
            <div class="plate" id="game-plate">
                <div class="grid-container">
                    <div class="game-grid" id="game-grid" data-size="{{ puzzle.size }}">
                        <!-- Le celle verranno generate dinamicamente dal JavaScript -->
                    </div>
                </div>
            </div>

            <!-- Pannello di controllo -->
            <div class="game-controls">
                <div class="game-info">
                    <div class="game-status">
                        <span id="status-text">Piazza le bollicine di brodo...</span>
                    </div>
                </div>

                <div class="control-buttons">
                    <button id="reset-btn" class="btn btn-secondary">
                        üîÑ Ricomincia
                    </button>
                    <button id="new-puzzle-btn" class="btn btn-primary">
                        üé≤ Nuovo Puzzle
                    </button>
                </div>

                <div class="progress-info">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <span id="progress-text">0/{{ puzzle.size }} bolle piazzate</span>
                </div>
            </div>
        </div>

        <!-- Zona vittoria -->
        <div class="victory-message" id="victory-message" style="display: none;">
            <div class="victory-content">
                <h2>üéâ Complimenti!</h2>
                <p>Hai riempito il piatto!</p>
                <button id="victory-new-puzzle" class="btn btn-primary">
                    üé≤ Nuovo Puzzle
                </button>
            </div>
        </div>
    </section>

    <!-- Regole del gioco -->
    <section class="game-rules">
        <div class="rules-container">
            <h2>Come si gioca:</h2>
            <ul>
                <li>ü´ß Piazza una bolla di brodo in ogni zona colorata</li>
                <li>üìè Ogni riga e colonna deve avere esattamente una bolla</li>
                <li>üö´ Le bolle non possono essere adiacenti (neanche in diagonale)</li>
                <li>üçù Usa i cappelletti per segnare ipotesi (non contano per le regole)</li>
                <li>üéØ Riempi il piatto!</li>
            </ul>
        </div>
    </section>
</div>

<!-- Dati del puzzle per JavaScript -->
<script>
/* eslint-disable */
// @ts-nocheck
// Dati del puzzle (template Django variables)
const puzzleData = {
    "id": "{{ puzzle.id }}",
    "size": {{ puzzle.size }},
    "zones": {{ puzzle_zones_json|safe }}
};

console.log("Puzzle data loaded:", puzzleData);

class CapletGame {
    constructor(puzzleData) {
        this.puzzle = puzzleData;
        this.size = puzzleData.size;
        this.zones = puzzleData.zones;
        this.grid = Array(this.size).fill().map(() => Array(this.size).fill(0)); // 0=vuoto, 1=cappelletto, 2=bolla
        this.selectedCell = null;

        this.initializeGame();
        this.bindEvents();
    }

    initializeGame() {
        this.createGrid();
        this.updateStatus();
        this.updateProgress();
    }

    createGrid() {
        const gameGrid = document.getElementById('game-grid');
        gameGrid.innerHTML = '';

        // Imposta le dimensioni della griglia CSS
        gameGrid.style.gridTemplateColumns = `repeat(${this.size}, 1fr)`;
        gameGrid.style.gridTemplateRows = `repeat(${this.size}, 1fr)`;

        for (let row = 0; row < this.size; row++) {
            for (let col = 0; col < this.size; col++) {
                const cell = document.createElement('div');
                cell.className = 'game-cell';
                cell.dataset.row = row;
                cell.dataset.col = col;

                // Assegna il colore della zona
                const zone = this.zones[row][col];
                cell.dataset.zone = zone;
                cell.style.backgroundColor = this.getZoneColor(zone);

                // Non aggiungiamo pi√π i numeri delle zone

                gameGrid.appendChild(cell);
            }
        }
    }

    getZoneColor(zone) {
        const colors = [
            '#FFD700', // Oro
            '#87CEEB', // Azzurro cielo
            '#DDA0DD', // Prugna
            '#98FB98', // Verde pallido
            '#FFB6C1', // Rosa chiaro
            '#F0E68C', // Khaki
            '#AFEEEE', // Turchese pallido
            '#FFDAB9'  // Pesca
        ];
        return colors[(zone - 1) % colors.length];
    }

    bindEvents() {
        // Click sulle celle
        document.getElementById('game-grid').addEventListener('click', (e) => {
            const cell = e.target.closest('.game-cell');
            if (cell) {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                this.toggleCell(row, col);
            }
        });

        // Pulsanti di controllo
        document.getElementById('reset-btn').addEventListener('click', () => this.resetGame());
        document.getElementById('new-puzzle-btn').addEventListener('click', () => this.newPuzzle());
        document.getElementById('victory-new-puzzle').addEventListener('click', () => this.newPuzzle());
    }

    toggleCell(row, col) {
        // Cicla tra: 0 (vuoto) -> 1 (cappelletto) -> 2 (bolla) -> 0 (vuoto)
        this.grid[row][col] = (this.grid[row][col] + 1) % 3;

        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);

        // Rimuovi eventuali simboli esistenti
        const existingSymbol = cell.querySelector('.symbol');
        if (existingSymbol) existingSymbol.remove();

        // Rimuovi le classi di stato
        cell.classList.remove('has-hat', 'has-bubble');

        // Aggiungi il nuovo simbolo
        if (this.grid[row][col] === 1) {
            // Cappelletto (pasta ripiena)
            cell.classList.add('has-hat');
            const symbol = document.createElement('div');
            const randomRotation = Math.floor(Math.random() * 8);
            symbol.className = `symbol hat rotate-${randomRotation}`;
            symbol.textContent = ''; // Usiamo l'icona SVG
            cell.appendChild(symbol);
        } else if (this.grid[row][col] === 2) {
            // Bolla gialla
            cell.classList.add('has-bubble');
            const symbol = document.createElement('div');
            symbol.className = 'symbol bubble';
            symbol.textContent = 'ü´ß';
            cell.appendChild(symbol);
        }

        this.updateStatus();
        this.updateProgress();
        this.checkVictory();
    }

    updateStatus() {
        const violations = this.getViolations();
        const statusText = document.getElementById('status-text');

        if (violations.length === 0) {
            const bubbleCount = this.countBubbles();
            if (bubbleCount === this.size) {
                statusText.textContent = 'üéâ Puzzle risolto!';
                statusText.className = 'status-success';
            } else {
                statusText.textContent = 'Ottimo! Continua cos√¨...';
                statusText.className = 'status-good';
            }
        } else {
            statusText.textContent = violations[0];
            statusText.className = 'status-error';
        }
    }

    getViolations() {
        const violations = [];

        // Controlla righe (solo le bolle contano, non i cappelletti)
        for (let row = 0; row < this.size; row++) {
            const rowBubbles = this.grid[row].filter(cell => cell === 2).length;
            if (rowBubbles > 1) {
                violations.push(`‚ùå Riga ${row + 1}: troppe bolle`);
            }
        }

        // Controlla colonne (solo le bolle contano)
        for (let col = 0; col < this.size; col++) {
            let colBubbles = 0;
            for (let row = 0; row < this.size; row++) {
                if (this.grid[row][col] === 2) colBubbles++;
            }
            if (colBubbles > 1) {
                violations.push(`‚ùå Colonna ${col + 1}: troppe bolle`);
            }
        }

        // Controlla zone (solo le bolle contano)
        const zoneBubbles = {};
        for (let row = 0; row < this.size; row++) {
            for (let col = 0; col < this.size; col++) {
                if (this.grid[row][col] === 2) {
                    const zone = this.zones[row][col];
                    zoneBubbles[zone] = (zoneBubbles[zone] || 0) + 1;
                }
            }
        }

        for (const [zone, count] of Object.entries(zoneBubbles)) {
            if (count > 1) {
                violations.push(`‚ùå Zona ${zone}: troppe bolle`);
            }
        }

        // Controlla adiacenze (solo le bolle contano)
        for (let row = 0; row < this.size; row++) {
            for (let col = 0; col < this.size; col++) {
                if (this.grid[row][col] === 2) {
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            const newRow = row + dr;
                            const newCol = col + dc;
                            if (newRow >= 0 && newRow < this.size &&
                                newCol >= 0 && newCol < this.size &&
                                this.grid[newRow][newCol] === 2) {
                                violations.push(`‚ùå Bolle adiacenti trovate`);
                                return violations;
                            }
                        }
                    }
                }
            }
        }

        return violations;
    }

    countBubbles() {
        let count = 0;
        for (let row = 0; row < this.size; row++) {
            for (let col = 0; col < this.size; col++) {
                if (this.grid[row][col] === 2) count++;
            }
        }
        return count;
    }

    updateProgress() {
        const bubbleCount = this.countBubbles();
        const progressPercent = (bubbleCount / this.size) * 100;

        document.getElementById('progress-fill').style.width = `${progressPercent}%`;
        document.getElementById('progress-text').textContent = `${bubbleCount}/${this.size} bolle piazzate`;
    }

    checkVictory() {
        const violations = this.getViolations();
        const bubbleCount = this.countBubbles();

        if (violations.length === 0 && bubbleCount === this.size) {
            setTimeout(() => {
                this.showVictoryAnimation();
            }, 500);
        }
    }

    showVictoryAnimation() {
        const gameGrid = document.getElementById('game-grid');
        const plate = document.getElementById('game-plate');

        // Raccogli tutti i cappelletti e le bolle dalla griglia
        const cappelletti = [];
        const bolle = [];

        document.querySelectorAll('.game-cell').forEach(cell => {
            const cappelletto = cell.querySelector('.symbol.hat');
            const bolla = cell.querySelector('.symbol.bubble');

            if (cappelletto) {
                const rect = cell.getBoundingClientRect();
                const plateRect = plate.getBoundingClientRect();
                cappelletti.push({
                    element: cappelletto.cloneNode(true),
                    x: ((rect.left - plateRect.left) / plateRect.width) * 100,
                    y: ((rect.top - plateRect.top) / plateRect.height) * 100
                });
            }

            if (bolla) {
                const rect = cell.getBoundingClientRect();
                const plateRect = plate.getBoundingClientRect();
                bolle.push({
                    element: bolla.cloneNode(true),
                    x: ((rect.left - plateRect.left) / plateRect.width) * 100,
                    y: ((rect.top - plateRect.top) / plateRect.height) * 100
                });
            }
        });

        // Fai sparire solo la struttura della griglia mantenendo i simboli dove sono
        document.querySelectorAll('.game-cell').forEach(cell => {
            cell.style.transition = 'background-color 1.5s ease-out, border-color 1.5s ease-out';
            cell.style.backgroundColor = 'transparent';
            cell.style.borderColor = 'transparent';
        });

        setTimeout(() => {
            // Fai sparire anche il contenitore della griglia
            const gameGrid = document.getElementById('game-grid');
            gameGrid.style.transition = 'background 1s ease-out, padding 1s ease-out, border-radius 1s ease-out';
            gameGrid.style.background = 'transparent';
            gameGrid.style.padding = '0';
            gameGrid.style.borderRadius = '0';

            // Aggiungi semplicemente il brodo dietro la griglia esistente
            const gridContainer = document.querySelector('.grid-container');
            gridContainer.style.background = 'radial-gradient(circle, rgba(255, 215, 0, 0.8) 0%, rgba(255, 193, 7, 0.6) 100%)';
            gridContainer.style.borderRadius = '50%';
            gridContainer.style.transition = 'background 2s ease-in-out';

            // Aggiungi l'effetto brodo al piatto
            plate.style.background = 'linear-gradient(135deg, #FFD700 0%, #FFC107 50%, #FFB300 100%)';
            plate.style.transition = 'background 2s ease-in-out';

            // Fai ondulare le icone come se galleggiassero nel brodo
            setTimeout(() => {
                document.querySelectorAll('.symbol').forEach((symbol, index) => {
                    symbol.style.animation = `floatInBroth ${3 + Math.random() * 2}s ease-in-out infinite`;
                    symbol.style.animationDelay = `${index * 0.2}s`;
                });
            }, 1000);

            // Mostra il messaggio di vittoria
            setTimeout(() => {
                document.getElementById('victory-message').style.display = 'block';
            }, 2500);
        }, 1500);
    }

    resetGame() {
        this.grid = Array(this.size).fill().map(() => Array(this.size).fill(0));

        // Ripristina la griglia originale se √® stata sostituita dall'animazione di vittoria
        const plate = document.getElementById('game-plate');
        const gameGrid = document.getElementById('game-grid');

        if (!gameGrid || gameGrid.style.opacity === '0') {
            this.initializeGame(); // Ricrea completamente la griglia
        } else {
            // Rimuovi tutti i simboli dalle celle esistenti
            document.querySelectorAll('.game-cell').forEach(cell => {
                cell.classList.remove('has-bubble', 'has-hat');
                const symbol = cell.querySelector('.symbol');
                if (symbol) symbol.remove();
            });
        }

        document.getElementById('victory-message').style.display = 'none';
        this.updateStatus();
        this.updateProgress();
    }


    newPuzzle() {
        window.location.reload();
    }
}

// Inizializza il gioco quando la pagina √® caricata
document.addEventListener('DOMContentLoaded', () => {
    new CapletGame(puzzleData);
});
</script>
{% endblock %}