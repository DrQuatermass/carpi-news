{% extends 'base.html' %}
{% load static %}

{% block title %}Caplet - Il gioco strategico{% endblock %}

{% block extra_css %}
<!-- Open Graph meta tags per condivisione social -->
<meta property="og:title" content="Caplet - Il gioco delle bolle nel brodo">
<meta property="og:description" content="Ho riempito il piatto! Sai fare di meglio? Prova questo gioco di logica su Ombra del Portico">
<meta property="og:image" content="{{ request.scheme }}://{{ request.get_host }}{% static 'home/images/cappelletto.png' %}">
<meta property="og:url" content="{{ request.build_absolute_uri }}">
<meta property="og:type" content="game">
<meta property="og:site_name" content="Ombra del Portico">

<!-- Twitter Card meta tags -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Caplet - Il gioco delle bolle nel brodo">
<meta name="twitter:description" content="Ho riempito il piatto! Sai fare di meglio? Prova questo gioco di logica su Ombra del Portico">
<meta name="twitter:image" content="{{ request.scheme }}://{{ request.get_host }}{% static 'home/images/cappelletto.png' %}">
<meta name="twitter:site" content="@ombradelportico">

<!-- Meta description generale -->
<meta name="description" content="Gioca a Caplet, il gioco delle bolle nel brodo. Piazza i segnalini seguendo le regole delle zone, righe e colonne.">
{% endblock %}

{% block content %}
<div class="container">
    <!-- Titolo del gioco -->
    <div class="game-header">
        <h1 class="game-title">Caplet</h1>
        <p class="game-subtitle">Il gioco delle bolle nel brodo</p>
    </div>

    <!-- Area di gioco -->
    <section class="game-section">
        <!-- Timer sopra tutto -->
        <div class="timer-display" style="text-align: center; margin-bottom: 20px;">
            <span id="timer-text" style="font-size: 2rem; font-weight: bold;">00:00</span>
        </div>

        <div class="game-container">
            <!-- Piatto rotondo -->
            <div class="plate" id="game-plate">
                <div class="grid-container">
                    <div class="game-grid" id="game-grid" data-size="{{ puzzle.size }}">
                        <!-- Le celle verranno generate dinamicamente dal JavaScript -->
                    </div>
                </div>
            </div>

            <!-- Pannello di controllo -->
            <div class="game-controls">
                <div class="game-info">
                    <div class="game-status">
                        <span id="status-text">Piazza le bollicine di brodo...</span>
                    </div>
                </div>

                <div class="control-buttons">
                    <button id="reset-btn" class="btn btn-secondary">
                        Ricomincia
                    </button>
                    <button id="new-puzzle-btn" class="btn btn-primary">
                        Nuovo Puzzle
                    </button>
                </div>

                <div class="progress-info">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <span id="progress-text">0/{{ puzzle.size }} bolle piazzate</span>
                </div>
            </div>
        </div>

        <!-- Zona vittoria -->
        <div class="victory-message" id="victory-message" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 1000; align-items: center; justify-content: center;">
            <div class="victory-content" style="background: linear-gradient(135deg, #fff 0%, #f8f9fa 100%); border-radius: 15px; padding: 40px; max-width: 500px; width: 90%; text-align: center; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3); border: 3px solid #FFD700; position: relative;">
                <button id="close-victory" style="position: absolute; top: 15px; right: 15px; background: none; border: none; font-size: 24px; cursor: pointer; color: #666; line-height: 1; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 50%;" onmouseover="this.style.backgroundColor='#f0f0f0'" onmouseout="this.style.backgroundColor='transparent'">√ó</button>
                <h2 style="color: #2c3e50; margin-bottom: 15px; font-size: 2rem;">Complimenti!</h2>
                <p style="color: #34495e; margin-bottom: 20px; font-size: 1.1rem;">Hai completato il puzzle Caplet!</p>

                <div class="completion-time" style="background: #fff3cd; border-radius: 10px; padding: 15px; margin: 20px 0; border-left: 5px solid #FFD700;">
                    <span id="final-time" style="font-size: 1.5rem; font-weight: bold; color: #856404;">Tempo: 00:00</span>
                </div>

                <div class="share-section" style="margin: 25px 0;">
                    <h3 style="color: #2c3e50; margin-bottom: 15px; font-size: 1.2rem;">Condividi Caplet:</h3>
                    <div class="social-share-buttons" style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; margin: 20px 0;">
                        <a id="facebook-share" href="https://www.facebook.com/sharer/sharer.php?u={{ request.build_absolute_uri }}&quote=Ho%20riempito%20il%20piatto!%20Sai%20fare%20di%20meglio?%20Prova%20Caplet%20su%20Ombra%20del%20Portico"
                           target="_blank" rel="noopener noreferrer"
                           class="social-btn facebook" style="background: linear-gradient(135deg, #4267B2, #365899); color: white; text-decoration: none; padding: 15px; border-radius: 50%; font-weight: 500; transition: transform 0.2s; display: inline-flex; align-items: center; justify-content: center;">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
                            </svg>
                        </a>
                        <a id="twitter-share" href="https://twitter.com/intent/tweet?text=Ho%20riempito%20il%20piatto!%20Sai%20fare%20di%20meglio?%20Prova%20Caplet%20su%20Ombra%20del%20Portico&url={{ request.build_absolute_uri|urlencode }}"
                           target="_blank" rel="noopener noreferrer"
                           class="social-btn x-twitter" style="background: linear-gradient(135deg, #000000, #1a1a1a); color: white; text-decoration: none; padding: 15px; border-radius: 50%; font-weight: 500; transition: transform 0.2s; display: inline-flex; align-items: center; justify-content: center;">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                            </svg>
                        </a>
                        <a id="whatsapp-share" href="https://wa.me/?text=Ho%20riempito%20il%20piatto!%20Sai%20fare%20di%20meglio?%20Prova%20Caplet%20su%20Ombra%20del%20Portico%20{{ request.build_absolute_uri|urlencode }}"
                           target="_blank" rel="noopener noreferrer"
                           class="social-btn whatsapp" style="background: linear-gradient(135deg, #25D366, #128C7E); color: white; text-decoration: none; padding: 15px; border-radius: 50%; font-weight: 500; transition: transform 0.2s; display: inline-flex; align-items: center; justify-content: center;">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893A11.821 11.821 0 0020.885 3.488"/>
                            </svg>
                        </a>
                        <button id="copy-link" class="social-btn copy-link" style="background: linear-gradient(135deg, #6c757d, #5a6268); color: white; border: none; padding: 15px; border-radius: 50%; font-weight: 500; transition: transform 0.2s; cursor: pointer; display: inline-flex; align-items: center; justify-content: center;">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/>
                            </svg>
                        </button>
                    </div>
                </div>

                <div class="victory-actions" style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin-top: 25px;">
                    <button id="victory-new-puzzle" class="btn" style="background: linear-gradient(135deg, #28a745, #20c997); color: white; border: none; padding: 15px 25px; border-radius: 25px; font-weight: 600; font-size: 1.1rem; transition: transform 0.2s; cursor: pointer;">
                        Nuovo Puzzle
                    </button>
                    <button id="back-to-home" class="btn" style="background: linear-gradient(135deg, #6c757d, #5a6268); color: white; border: none; padding: 15px 25px; border-radius: 25px; font-weight: 600; font-size: 1.1rem; transition: transform 0.2s; cursor: pointer;" onclick="window.location.href='/'">
                        Torna alla Home
                    </button>
                </div>
            </div>
        </div>
    </section>

    <!-- Regole del gioco -->
    <section class="game-rules">
        <div class="rules-container">
            <h2>Come si gioca:</h2>
            <ul>
                <li>Piazza una bolla di brodo in ogni zona colorata</li>
                <li>Ogni riga e colonna deve avere esattamente una bolla</li>
                <li>Le bolle non possono essere adiacenti (neanche in diagonale)</li>
                <li>Usa i cappelletti per segnare ipotesi (non contano per le regole)</li>
                <li>Riempi il piatto!</li>
            </ul>
        </div>
    </section>
</div>

<!-- Dati del puzzle per JavaScript -->
<script>
/* eslint-disable */
// @ts-nocheck
// Dati del puzzle (template Django variables)
const puzzleData = {
    "id": "{{ puzzle.id }}",
    "size": {{ puzzle.size }},
    "zones": {{ puzzle_zones_json|safe }}
};

console.log("Puzzle data loaded:", puzzleData);

class CapletGame {
    constructor(puzzleData) {
        this.puzzle = puzzleData;
        this.size = puzzleData.size;
        this.zones = puzzleData.zones;
        this.grid = Array(this.size).fill().map(() => Array(this.size).fill(0)); // 0=vuoto, 1=cappelletto, 2=bolla
        this.selectedCell = null;
        this.startTime = null;
        this.timerInterval = null;
        this.gameCompleted = false;

        this.initializeGame();
        this.bindEvents();
    }

    initializeGame() {
        this.createGrid();
        this.updateStatus();
        this.updateProgress();
        this.resetTimer();
    }

    createGrid() {
        const gameGrid = document.getElementById('game-grid');
        gameGrid.innerHTML = '';

        // Imposta le dimensioni della griglia CSS
        gameGrid.style.gridTemplateColumns = `repeat(${this.size}, 1fr)`;
        gameGrid.style.gridTemplateRows = `repeat(${this.size}, 1fr)`;

        for (let row = 0; row < this.size; row++) {
            for (let col = 0; col < this.size; col++) {
                const cell = document.createElement('div');
                cell.className = 'game-cell';
                cell.dataset.row = row;
                cell.dataset.col = col;

                // Assegna il colore della zona
                const zone = this.zones[row][col];
                cell.dataset.zone = zone;
                cell.style.backgroundColor = this.getZoneColor(zone);

                // Non aggiungiamo pi√π i numeri delle zone

                gameGrid.appendChild(cell);
            }
        }
    }

    getZoneColor(zone) {
        const colors = [
            '#FFD700', // Oro
            '#87CEEB', // Azzurro cielo
            '#DDA0DD', // Prugna
            '#98FB98', // Verde pallido
            '#FFB6C1', // Rosa chiaro
            '#F0E68C', // Khaki
            '#AFEEEE', // Turchese pallido
            '#FFDAB9'  // Pesca
        ];
        return colors[(zone - 1) % colors.length];
    }

    bindEvents() {
        // Click sulle celle
        document.getElementById('game-grid').addEventListener('click', (e) => {
            const cell = e.target.closest('.game-cell');
            if (cell) {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                this.toggleCell(row, col);
            }
        });

        // Pulsanti di controllo
        document.getElementById('reset-btn').addEventListener('click', () => this.resetGame());
        document.getElementById('new-puzzle-btn').addEventListener('click', () => this.newPuzzle());
        document.getElementById('victory-new-puzzle').addEventListener('click', () => this.newPuzzle());

        // Pulsante copia link (solo questo rimane)
        document.getElementById('copy-link').addEventListener('click', () => this.copyGameLink());

        // Chiusura popup di vittoria
        document.getElementById('close-victory').addEventListener('click', () => this.closeVictoryMessage());
        document.getElementById('victory-message').addEventListener('click', (e) => {
            if (e.target.id === 'victory-message') {
                this.closeVictoryMessage();
            }
        });
    }

    toggleCell(row, col) {
        // Avvia il timer alla prima mossa
        if (!this.startTime && !this.gameCompleted) {
            this.startTimer();
        }

        // Cicla tra: 0 (vuoto) -> 1 (cappelletto) -> 2 (bolla) -> 0 (vuoto)
        this.grid[row][col] = (this.grid[row][col] + 1) % 3;

        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);

        // Rimuovi eventuali simboli esistenti
        const existingSymbol = cell.querySelector('.symbol');
        if (existingSymbol) existingSymbol.remove();

        // Rimuovi le classi di stato
        cell.classList.remove('has-hat', 'has-bubble');

        // Aggiungi il nuovo simbolo
        if (this.grid[row][col] === 1) {
            // Cappelletto (pasta ripiena)
            cell.classList.add('has-hat');
            const symbol = document.createElement('div');
            const randomRotation = Math.floor(Math.random() * 8);
            symbol.className = `symbol hat rotate-${randomRotation}`;
            symbol.textContent = ''; // Usiamo l'icona SVG
            cell.appendChild(symbol);
        } else if (this.grid[row][col] === 2) {
            // Bolla gialla
            cell.classList.add('has-bubble');
            const symbol = document.createElement('div');
            symbol.className = 'symbol bubble';
            symbol.textContent = 'ü´ß';
            cell.appendChild(symbol);
        }

        this.updateStatus();
        this.updateProgress();
        this.checkVictory();
    }

    updateStatus() {
        const violations = this.getViolations();
        const statusText = document.getElementById('status-text');

        if (violations.length === 0) {
            const bubbleCount = this.countBubbles();
            if (bubbleCount === this.size) {
                statusText.textContent = 'Puzzle risolto!';
                statusText.className = 'status-success';
            } else {
                statusText.textContent = 'Ottimo! Continua cos√¨...';
                statusText.className = 'status-good';
            }
        } else {
            statusText.textContent = violations[0];
            statusText.className = 'status-error';
        }
    }

    getViolations() {
        const violations = [];

        // Controlla righe (solo le bolle contano, non i cappelletti)
        for (let row = 0; row < this.size; row++) {
            const rowBubbles = this.grid[row].filter(cell => cell === 2).length;
            if (rowBubbles > 1) {
                violations.push(`Riga ${row + 1}: troppe bolle`);
            }
        }

        // Controlla colonne (solo le bolle contano)
        for (let col = 0; col < this.size; col++) {
            let colBubbles = 0;
            for (let row = 0; row < this.size; row++) {
                if (this.grid[row][col] === 2) colBubbles++;
            }
            if (colBubbles > 1) {
                violations.push(`Colonna ${col + 1}: troppe bolle`);
            }
        }

        // Controlla zone (solo le bolle contano)
        const zoneBubbles = {};
        for (let row = 0; row < this.size; row++) {
            for (let col = 0; col < this.size; col++) {
                if (this.grid[row][col] === 2) {
                    const zone = this.zones[row][col];
                    zoneBubbles[zone] = (zoneBubbles[zone] || 0) + 1;
                }
            }
        }

        for (const [zone, count] of Object.entries(zoneBubbles)) {
            if (count > 1) {
                violations.push(`Zona ${zone}: troppe bolle`);
            }
        }

        // Controlla adiacenze (solo le bolle contano)
        for (let row = 0; row < this.size; row++) {
            for (let col = 0; col < this.size; col++) {
                if (this.grid[row][col] === 2) {
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (dr === 0 && dc === 0) continue;
                            const newRow = row + dr;
                            const newCol = col + dc;
                            if (newRow >= 0 && newRow < this.size &&
                                newCol >= 0 && newCol < this.size &&
                                this.grid[newRow][newCol] === 2) {
                                violations.push(`Bolle adiacenti trovate`);
                                return violations;
                            }
                        }
                    }
                }
            }
        }

        return violations;
    }

    countBubbles() {
        let count = 0;
        for (let row = 0; row < this.size; row++) {
            for (let col = 0; col < this.size; col++) {
                if (this.grid[row][col] === 2) count++;
            }
        }
        return count;
    }

    updateProgress() {
        const bubbleCount = this.countBubbles();
        const progressPercent = (bubbleCount / this.size) * 100;

        document.getElementById('progress-fill').style.width = `${progressPercent}%`;
        document.getElementById('progress-text').textContent = `${bubbleCount}/${this.size} bolle piazzate`;
    }

    checkVictory() {
        const violations = this.getViolations();
        const bubbleCount = this.countBubbles();

        if (violations.length === 0 && bubbleCount === this.size) {
            this.gameCompleted = true;
            this.stopTimer();
            setTimeout(() => {
                this.showVictoryAnimation();
            }, 500);
        }
    }

    showVictoryAnimation() {
        const gameGrid = document.getElementById('game-grid');
        const plate = document.getElementById('game-plate');

        // Raccogli tutti i cappelletti e le bolle dalla griglia
        const cappelletti = [];
        const bolle = [];

        document.querySelectorAll('.game-cell').forEach(cell => {
            const cappelletto = cell.querySelector('.symbol.hat');
            const bolla = cell.querySelector('.symbol.bubble');

            if (cappelletto) {
                const rect = cell.getBoundingClientRect();
                const plateRect = plate.getBoundingClientRect();
                cappelletti.push({
                    element: cappelletto.cloneNode(true),
                    x: ((rect.left - plateRect.left) / plateRect.width) * 100,
                    y: ((rect.top - plateRect.top) / plateRect.height) * 100
                });
            }

            if (bolla) {
                const rect = cell.getBoundingClientRect();
                const plateRect = plate.getBoundingClientRect();
                bolle.push({
                    element: bolla.cloneNode(true),
                    x: ((rect.left - plateRect.left) / plateRect.width) * 100,
                    y: ((rect.top - plateRect.top) / plateRect.height) * 100
                });
            }
        });

        // Fai sparire solo la struttura della griglia mantenendo i simboli dove sono
        document.querySelectorAll('.game-cell').forEach(cell => {
            cell.style.transition = 'background-color 1.5s ease-out, border-color 1.5s ease-out';
            cell.style.backgroundColor = 'transparent';
            cell.style.borderColor = 'transparent';
        });

        setTimeout(() => {
            // Fai sparire anche il contenitore della griglia
            const gameGrid = document.getElementById('game-grid');
            gameGrid.style.transition = 'background 1s ease-out, padding 1s ease-out, border-radius 1s ease-out';
            gameGrid.style.background = 'transparent';
            gameGrid.style.padding = '0';
            gameGrid.style.borderRadius = '0';

            // Aggiungi semplicemente il brodo dietro la griglia esistente
            const gridContainer = document.querySelector('.grid-container');
            gridContainer.style.background = 'radial-gradient(circle, rgba(255, 215, 0, 0.8) 0%, rgba(255, 193, 7, 0.6) 100%)';
            gridContainer.style.borderRadius = '50%';
            gridContainer.style.transition = 'background 2s ease-in-out';

            // Aggiungi l'effetto brodo al piatto
            plate.style.background = 'linear-gradient(135deg, #FFD700 0%, #FFC107 50%, #FFB300 100%)';
            plate.style.transition = 'background 2s ease-in-out';

            // Fai ondulare le icone come se galleggiassero nel brodo
            setTimeout(() => {
                document.querySelectorAll('.symbol').forEach((symbol, index) => {
                    symbol.style.animation = `floatInBroth ${3 + Math.random() * 2}s ease-in-out infinite`;
                    symbol.style.animationDelay = `${index * 0.2}s`;
                });
            }, 1000);

            // Mostra il messaggio di vittoria
            setTimeout(() => {
                this.showFinalTime();
                document.getElementById('victory-message').style.display = 'flex';
            }, 2500);
        }, 1500);
    }

    resetGame() {
        this.grid = Array(this.size).fill().map(() => Array(this.size).fill(0));
        this.gameCompleted = false;
        // Non resettare il timer - solo pulire la griglia

        // Ripristina la griglia originale se √® stata sostituita dall'animazione di vittoria
        const plate = document.getElementById('game-plate');
        const gameGrid = document.getElementById('game-grid');

        if (!gameGrid || gameGrid.style.opacity === '0') {
            this.initializeGame(); // Ricrea completamente la griglia
        } else {
            // Rimuovi tutti i simboli dalle celle esistenti
            document.querySelectorAll('.game-cell').forEach(cell => {
                cell.classList.remove('has-bubble', 'has-hat');
                const symbol = cell.querySelector('.symbol');
                if (symbol) symbol.remove();
            });
        }

        document.getElementById('victory-message').style.display = 'none';
        this.updateStatus();
        this.updateProgress();
    }


    newPuzzle() {
        window.location.reload();
    }

    startTimer() {
        this.startTime = Date.now();
        this.timerInterval = setInterval(() => {
            this.updateTimer();
        }, 1000);
    }

    stopTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
    }

    resetTimer() {
        this.stopTimer();
        this.startTime = null;
        this.gameCompleted = false;
        document.getElementById('timer-text').textContent = '‚è±Ô∏è 00:00';
    }

    updateTimer() {
        if (!this.startTime || this.gameCompleted) return;

        const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;

        const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        document.getElementById('timer-text').textContent = `‚è±Ô∏è ${timeString}`;
    }

    showFinalTime() {
        if (!this.startTime) return;

        const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;

        const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        document.getElementById('final-time').textContent = `Tempo: ${timeString}`;

        // Aggiorna i link di condivisione con il tempo
        this.updateSharingLinks(timeString);
    }

    updateSharingLinks(timeString) {
        const baseUrl = window.location.href;
        const shareText = `Ho riempito il piatto in ${timeString}. Sai fare di meglio? Prova Caplet su Ombra del Portico`;
        const shareTextEncoded = encodeURIComponent(shareText);
        const urlEncoded = encodeURIComponent(baseUrl);

        // Aggiorna Facebook
        const facebookLink = document.getElementById('facebook-share');
        facebookLink.href = `https://www.facebook.com/sharer/sharer.php?u=${baseUrl}&quote=${shareTextEncoded}`;

        // Aggiorna X/Twitter
        const twitterLink = document.getElementById('twitter-share');
        twitterLink.href = `https://twitter.com/intent/tweet?text=${shareTextEncoded}&url=${urlEncoded}`;

        // Aggiorna WhatsApp
        const whatsappLink = document.getElementById('whatsapp-share');
        whatsappLink.href = `https://wa.me/?text=${shareTextEncoded}%20${urlEncoded}`;
    }


    async copyGameLink() {
        try {
            let shareText;
            if (this.startTime && this.gameCompleted) {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                shareText = `Ho riempito il piatto in ${timeString}. Sai fare di meglio? Prova Caplet su Ombra del Portico: ${window.location.href}`;
            } else {
                shareText = `Ho riempito il piatto! Sai fare di meglio? Prova Caplet su Ombra del Portico: ${window.location.href}`;
            }

            await navigator.clipboard.writeText(shareText);

            // Feedback visivo
            const button = document.getElementById('copy-link');
            const originalText = button.innerHTML;
            button.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg> Link Copiato!';
            button.style.backgroundColor = '#28a745';

            setTimeout(() => {
                button.innerHTML = originalText;
                button.style.backgroundColor = '';
            }, 2000);
        } catch (err) {
            // Fallback per browser che non supportano clipboard API
            let shareText;
            if (this.startTime && this.gameCompleted) {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                shareText = `Ho riempito il piatto in ${timeString}. Sai fare di meglio? Prova Caplet su Ombra del Portico: ${window.location.href}`;
            } else {
                shareText = `Ho riempito il piatto! Sai fare di meglio? Prova Caplet su Ombra del Portico: ${window.location.href}`;
            }

            const textArea = document.createElement('textarea');
            textArea.value = shareText;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);

            // Feedback visivo
            const button = document.getElementById('copy-link');
            const originalText = button.innerHTML;
            button.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg> Link Copiato!';
            button.style.backgroundColor = '#28a745';

            setTimeout(() => {
                button.innerHTML = originalText;
                button.style.backgroundColor = '';
            }, 2000);
        }
    }

    closeVictoryMessage() {
        document.getElementById('victory-message').style.display = 'none';
    }
}

// Inizializza il gioco quando la pagina √® caricata
document.addEventListener('DOMContentLoaded', () => {
    new CapletGame(puzzleData);
});
</script>
{% endblock %}